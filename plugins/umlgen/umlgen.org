#+TITLE: UMLGenerator
#+AUTHOR: Roman Zayrullin
#+EMAIL: krosenmann@gmail.com
#+STARTUP: showall
#+LaTeX_ClASS_OPTIONS: [11pt,a4paper,ubuntu]
#+LaTeX_HEADER:\usepackage[scale=0.75]{geometry}
#+LaTeX_HEADER:\usepackage[utf-8]{inputrec}

* Постановка задачи
  Проходить по файлу и генерировать на основе кода диаграммы с помощью
  plantuml. Показывая места разрешения в диалоговом режиме. ПРи этом
  отображать в буфере текущий код. 

* Решение

** Построение диаграммы классов
   Реализовать функцию прохода по буферу. По ключевому слову class
   получать имя класса Python. 
   # Проверять наличие полей ForeignKey и создавать от них
   # связи. Связи именовать по значению related_name

   #+begin_src emacs-lisp :tangle yes
     (defun python-umlgenerator()
       (interactive)
       (beginning-of-buffer)
       (plant-buffer-prepare)
       (while (< (line-number-at-pos) (line-number-at-pos(point-max)))
         (if (equal (current-word) "class")
             (progn
               (forward-word)
               (forward-char 2)
               (setq word (current-word))
               (if (string= word "Meta")
                   ()
                 (progn 
                   (plant-translator word)
                   (find-connect word))
               )))
         (next-line)
         (beginning-of-line)
         ))

     (defun find-connect(clsname)
       (while (not (member
                    (current-word) '("def" "class" "async")))
         (setq cur-str (thing-at-point 'line t))
         (when (string-match "[ForeignKey]" cur-str)
           (progn
             (beginning-of-line)
             (setq varname (current-word))
             (search-forward "Foreignkey")
             (forward-word)
             (forward-char 2)
             (setq type-class (current-word))
             (with-current-buffer "PlantUml"
               (insert "{\n" "+" varname ": " type-class "\n")))
           ))
       (with-current-buffer "PlantUml"
       )
   #+end_src

   #+RESULTS:
   : find-connect
 
   По полученному имени класса создавать аналогичный класс plantuml и
   помещать его в созданный временный буфер в plantuml-mode

   #+begin_src emacs-lisp :tangle yes  
     (defun plant-buffer-prepare()
       (setq cur-buf (buffer-name))
       (switch-to-buffer "PlantUml"
        ;; (format "*PlantUml %s*" cur-buf)
                         )
       (plantuml-mode)
       (switch-to-buffer cur-buf)
       )

     (defun plant-translator (word)
       (with-current-buffer "PlantUml"
         (insert
          (concat "class " word "\n"))))
     ;; (plant-translator "Todo")
   #+end_src

   #+RESULTS:
   : plant-translator
