#+TITLE: UMLGenerator
#+AUTHOR: Roman Zayrullin
#+EMAIL: krosenmann@gmail.com
#+STARTUP: showall
#+LaTeX_ClASS_OPTIONS: [11pt,a4paper,ubuntu]
#+LaTeX_HEADER:\usepackage[scale=0.75]{geometry}
#+LaTeX_HEADER:\usepackage[utf-8]{inputrec}

* Постановка задачи
  Проходить по файлу и генерировать на основе кода диаграммы с помощью
  plantuml. Показывая места разрешения в диалоговом режиме. ПРи этом
  отображать в буфере текущий код. 

** TODO Переписать с использованием bovinate

* Решение

** Построение диаграммы классов
   Если смотреть на объявление классов в Питоне, то, на самом деле,
   его синтаксическое дерево является достаточно простым. По-крайней
   мере, если говорить о построении диаграммы классов на основе
   имеющегося кода. 

   #+begin_src emacs-lisp :tangle yes
     (defclass related-class ()
       ((name :initarg :name)
        (parent :initarg :parent)
        (foreign-key :initarg :foreign-key)
        (fields :initarg :fileds)
        (methods :initarg :methods)
        ))

     (defmethod translate-to-plant ((obj related-class))
       (setq class-plantdia (concat "class " (oref obj name)"{\n"))
       (dolist (elem (oref obj methods))
         (setq class-plantdia (concat class-plantdia elem "()\n")))
       (setq class-plantdia (concat class-plantdia "}\n"))
       class-plantdia)

     (defmethod make-inherit-diagramm ((obj related-class))
       (concat (oref obj parent) " <|-- " (oref obj name)))

     (defmethod attrib-diagramm ((obj related-class))
       (setq val nil)
       (dolist (elem (oref obj foreign-key))
         (setq val (concat val "\n" (car elem) " -- " (oref obj name) ": " (cdr elem) "\n")))
       val)
   #+end_src
   
   При этом комментарии и докстринги выделяются на лист в виде заметок
   #+begin_src emacs-lisp :tangle yes
     (defun split-by-comment(str)
       (if (string-match-p (regexp-quote "#") str)
           (setq note-on (split-string "#"))
         (setq note-on str))
       note-on)
   #+end_src

   Каждый найденный класс разбирается по методам и атрибутам
   #+begin_src emacs-lisp :tangle yes

   #+end_src


   #+begin_src emacs-lisp :tangle yes
     (defun readline()
       (buffer-substring-no-properties
        (line-beginning-position)
        (line-end-position)))


     (end-of-defun)
     (set-mark)
     (kill-ring-save)

     (defun read-current-namespace()
       (get-attributes)
       (get-methods)
       (let (cl)
         (setq cl (split-by-comment (readline)))
         cl))

     (defun tree-generator()
       (beginning-of-buffer)
       (plant-buffer-prepare)
       (while (< (line-number-at-pos) (line-number-at-pos(point-max)))
         (setq curline (readline))
         (setq curline (split-string curline (readline)))
         (if (equal (car curline) "class")
             (progn
               (setq cur-c (make-instance 'related-class :name ()))
               (if (string= word "Meta")
                   nil
                 (progn 
                   (plant-translator word)
                   (find-connect word)))
               (read-current-namespace)
               ))
         (next-line)
         ))

     (defun find-connect(clsname)
       (while (not (member
                    (current-word) '("def" "class" "async")))
         (setq cur-str (thing-at-point 'line t))
         (when (string-match "ForeignKey" cur-str)
           (progn
             (beginning-of-line)
             (setq varname (current-word))
             (forward-char (string-match "ForeignKey" cur-str))
             (forward-to-word 1)
             (forward-char 1)
             (if (equal (current-word) "self")
                 (setq type-class clsname)
                 (setq type-class (current-word)))
             (beginning-of-line)
             ;; (if (string-match "related_name" cur-str)
             ;; (progn
             ;;   (forward-char (string-match "related_name" cur-str))
             ;;   (forward-to-word 2)
             ;;   (forward-char 2)
             ;;   (setq connect-name (current-word))
             ;;   )
             ;; (progn
             ;;   (end-of-line)
             ;;   (when (equal (string (preceding-char)) ",")
             ;;     (next-line)
             ;;     (beginning-of-line)
             ;;     (forward-char (string-match "related_name" cur-str))
             ;;     (forward-to-word 2)
             ;;     (forward-char 3)
             ;;     (setq connect-name (current-word))))
             ;; )
             (with-current-buffer "PlantUml"
               (insert "+" varname ": " "\n")
               (save-excursion  (end-of-buffer)
                                (insert type-class " -- " clsname": " varname "\n")))
               ))
         (next-line)
         (beginning-of-line))
       (with-current-buffer "PlantUml"
         (insert "}\n"))
       )
   #+end_src

   #+RESULTS:
   : find-connect

   Комментарии выдеяются в отедельные note.
   #+begin_src emacs-lisp :tangle yes
   #+end_src
 
   По полученному имени класса создавать аналогичный класс plantuml и
   помещать его в созданный временный буфер в plantuml-mode

   #+begin_src emacs-lisp :tangle yes  
     (defun plant-buffer-prepare()
       (setq cur-buf (buffer-name))
       (switch-to-buffer "PlantUml"
        ;; (format "*PlantUml %s*" cur-buf)
                         )
       (plantuml-mode)
       (switch-to-buffer cur-buf)
       )

     (defun plant-translator (word)
       (with-current-buffer "PlantUml"
         (insert
          (concat "class " word " {""\n"))))
     ;; (plant-translator "Todo")
   #+end_src

   #+RESULTS:
   : plant-translator

   Запускается функция из емакса по М-х python-umlclass-generator
   #+begin_src emacs-lisp :tangle yes
   (provide 'python-umlclass-generator)
   #+end_src
   
** TODO Определять енумы и ссылаться на них из модели

** TODO Диалоговый режим работы

** TODO Косметика

** TODO Проход по папкам и создание областей видимости.

** TODO Связи для унаследованных полей

** TODO Определять вот этих петучей
   #+begin_src python :tangle no
     query = """
             select %(select)s
             from {} as p
             right join {} as q on (p.code = q.product_id)
             left join {} as b on (b.product_id = q.product_id)
             %(where)s
             %(group_by)s
             %(order_by)s
             %(limit)s
         """.format(
             Product._meta.db_table,
             Quantity._meta.db_table,
             TemporaryQuantityBan._meta.db_table,
         )

         def get_objects_count(self):
             from django.db import connections
             cursor = connections['production'].cursor()
             cursor.execute(self.query % {
                 'select': 'count(q.id) as cnt',
                 'where': self.get_where(),
                 'group_by': '',
                 'order_by': '',
                 'limit': '',
             }, [])
             return cursor.fetchone()[0]
   #+end_src

